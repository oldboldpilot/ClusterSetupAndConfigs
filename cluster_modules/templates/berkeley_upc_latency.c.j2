// Berkeley UPC Point-to-Point Latency Benchmark
// Generated by ClusterSetupAndConfigs
// Author: Olumuyiwa Oluwasanmi
// Measures round-trip latency using UPC shared memory operations

#include <upc.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ITERATIONS {{ iterations }}
#define WARMUP_ITERATIONS {{ warmup_iterations }}

shared long data[THREADS];

// Get time in microseconds
static inline double get_time_us() {
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return ts.tv_sec * 1e6 + ts.tv_nsec / 1e3;
}

// Comparison function for qsort
int compare_doubles(const void *a, const void *b) {
    double da = *(const double*)a;
    double db = *(const double*)b;
    return (da > db) - (da < db);
}

void measure_latency(int iterations) {
    int rank = MYTHREAD;
    int nthreads = THREADS;
    
    if (nthreads < 2) {
        if (rank == 0) {
            fprintf(stderr, "Error: This benchmark requires at least 2 threads\n");
        }
        return;
    }
    
    upc_barrier;
    
    if (rank == 0) {
        printf("Berkeley UPC Point-to-Point Latency Benchmark\n");
        printf("=============================================\n");
        printf("Number of threads: %d\n", nthreads);
        printf("Iterations per measurement: %d\n", iterations);
        printf("\n");
        
        double *latencies = (double*)malloc(iterations * sizeof(double));
        
        // Measure latency to each other thread
        for (int target = 1; target < nthreads; target++) {
            // Warmup
            for (int i = 0; i < WARMUP_ITERATIONS; i++) {
                data[target] = 42;
                long val = data[target];
                (void)val;
            }
            
            // Actual measurements
            for (int i = 0; i < iterations; i++) {
                double start = get_time_us();
                data[target] = 42;
                long val = data[target];
                (void)val;
                double end = get_time_us();
                
                latencies[i] = end - start;
            }
            
            // Calculate statistics
            qsort(latencies, iterations, sizeof(double), compare_doubles);
            
            double min_lat = latencies[0];
            double max_lat = latencies[iterations - 1];
            double median_lat = latencies[iterations / 2];
            double avg_lat = 0.0;
            for (int i = 0; i < iterations; i++) {
                avg_lat += latencies[i];
            }
            avg_lat /= iterations;
            
            printf("Thread 0 <-> Thread %d:\n", target);
            printf("  Min latency:    %.3f us\n", min_lat);
            printf("  Max latency:    %.3f us\n", max_lat);
            printf("  Avg latency:    %.3f us\n", avg_lat);
            printf("  Median latency: %.3f us\n", median_lat);
            printf("\n");
        }
        
        free(latencies);
    } else {
        upc_barrier;
    }
}

int main(int argc, char** argv) {
    int iterations = ITERATIONS;
    
    if (argc > 1) {
        iterations = atoi(argv[1]);
    }
    
    measure_latency(iterations);
    return 0;
}
