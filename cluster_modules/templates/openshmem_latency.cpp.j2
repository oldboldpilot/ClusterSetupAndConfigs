// OpenSHMEM Point-to-Point Latency Benchmark
// Generated by ClusterSetupAndConfigs
// Author: Olumuyiwa Oluwasanmi
// Measures round-trip latency using shmem_put and shmem_get
// C++23 Standard with trailing return type syntax

#include <shmem.h>
#include <iostream>
#include <vector>
#include <algorithm>
#include <chrono>
#include <iomanip>
#include <ranges>
#include <numeric>

using namespace std;
using namespace std::chrono;


auto measure_latency(int iterations = {{ iterations }}) -> void {
    shmem_init();
    
    int rank = shmem_my_pe();
    int nprocs = shmem_n_pes();
    
    if (nprocs < 2) {
        if (rank == 0) {
            cerr << "Error: This benchmark requires at least 2 PEs" << endl;
        }
        shmem_finalize();
        return;
    }
    
    // Allocate symmetric data
    long *data = (long*)shmem_malloc(sizeof(long));
    *data = 42;
    
    shmem_barrier_all();
    
    if (rank == 0) {
        cout << "OpenSHMEM Point-to-Point Latency Benchmark" << endl;
        cout << "===========================================" << endl;
        cout << "Number of PEs: " << nprocs << endl;
        cout << "Iterations per measurement: " << iterations << endl;
        cout << endl;
        
        // Measure latency to each other PE
        for (int target = 1; target < nprocs; target++) {
            vector<double> latencies;
            
            // Warmup
            for (int i = 0; i < {{ warmup_iterations }}; i++) {
                shmem_long_put(data, data, 1, target);
                shmem_long_get(data, data, 1, target);
                shmem_quiet();
            }
            
            // Actual measurements
            for (int i = 0; i < iterations; i++) {
                auto start = high_resolution_clock::now();
                shmem_long_put(data, data, 1, target);
                shmem_long_get(data, data, 1, target);
                shmem_quiet();
                auto end = high_resolution_clock::now();
                
                double latency_us = duration_cast<nanoseconds>(end - start).count() / 1000.0;
                latencies.push_back(latency_us);
            }
            
            // Calculate statistics using C++23 ranges and algorithms
            std::sort(latencies.begin(), latencies.end());
            double min_lat = *std::min_element(latencies.begin(), latencies.end());
            double max_lat = *std::max_element(latencies.begin(), latencies.end());
            double median_lat = latencies[latencies.size() / 2];
            double avg_lat = std::reduce(latencies.begin(), latencies.end(), 0.0) / latencies.size();
            
            cout << "PE 0 <-> PE " << target << ":" << endl;
            cout << "  Min latency:    " << fixed << setprecision(3) << min_lat << " us" << endl;
            cout << "  Max latency:    " << max_lat << " us" << endl;
            cout << "  Avg latency:    " << avg_lat << " us" << endl;
            cout << "  Median latency: " << median_lat << " us" << endl;
            cout << endl;
        }
    } else {
        shmem_barrier_all();
    }
    
    shmem_free(data);
    shmem_finalize();
}

int main(int argc, char** argv) {
    int iterations = {{ iterations }};
    
    if (argc > 1) {
        iterations = atoi(argv[1]);
    }
    
    measure_latency(iterations);
    return 0;
}
