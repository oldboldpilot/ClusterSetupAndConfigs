// UPC++ Point-to-Point Latency Benchmark
// Generated by ClusterSetupAndConfigs
// Author: Olumuyiwa Oluwasanmi
// Measures round-trip latency between ranks using RPC
// C++23 Standard

#include <upcxx/upcxx.hpp>
#include <iostream>
#include <chrono>
#include <vector>
#include <algorithm>
#include <iomanip>
#include <ranges>
#include <numeric>

using namespace std;
using namespace std::chrono;
namespace ranges = std::ranges;

// Simple function for RPC ping
int ping_response() {
    return 42;
}

void measure_latency(int iterations = {{ iterations }}) {
    upcxx::init();
    
    int rank = upcxx::rank_me();
    int nprocs = upcxx::rank_n();
    
    if (nprocs < 2) {
        if (rank == 0) {
            cerr << "Error: This benchmark requires at least 2 processes" << endl;
        }
        upcxx::finalize();
        return;
    }
    
    // Barrier to synchronize all processes
    upcxx::barrier();
    
    if (rank == 0) {
        cout << "UPC++ Point-to-Point Latency Benchmark" << endl;
        cout << "========================================" << endl;
        cout << "Number of processes: " << nprocs << endl;
        cout << "Iterations per measurement: " << iterations << endl;
        cout << endl;
        
        // Measure latency to each other rank
        for (int target = 1; target < nprocs; target++) {
            vector<double> latencies;
            
            // Warmup
            for (int i = 0; i < {{ warmup_iterations }}; i++) {
                upcxx::rpc(target, ping_response).wait();
            }
            
            // Actual measurements
            for (int i = 0; i < iterations; i++) {
                auto start = high_resolution_clock::now();
                upcxx::rpc(target, ping_response).wait();
                auto end = high_resolution_clock::now();
                
                double latency_us = duration_cast<nanoseconds>(end - start).count() / 1000.0;
                latencies.push_back(latency_us);
            }
            
            // Calculate statistics using C++23 ranges and algorithms
            ranges::sort(latencies);
            double min_lat = ranges::min(latencies);
            double max_lat = ranges::max(latencies);
            double median_lat = latencies[latencies.size() / 2];
            double avg_lat = std::reduce(latencies.begin(), latencies.end(), 0.0) / latencies.size();
            
            cout << "Rank 0 -> Rank " << target << ":" << endl;
            cout << "  Min latency:    " << fixed << setprecision(3) << min_lat << " us" << endl;
            cout << "  Max latency:    " << max_lat << " us" << endl;
            cout << "  Avg latency:    " << avg_lat << " us" << endl;
            cout << "  Median latency: " << median_lat << " us" << endl;
            cout << endl;
        }
    } else {
        // Worker ranks just wait for RPCs
        upcxx::barrier();
    }
    
    upcxx::finalize();
}

int main(int argc, char** argv) {
    int iterations = {{ iterations }};
    
    if (argc > 1) {
        iterations = atoi(argv[1]);
    }
    
    measure_latency(iterations);
    return 0;
}
